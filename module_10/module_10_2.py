# Импорт необходимых библиотек для работы с потоками и временем
import threading
import time


# Создание класса Knight, наследующегося от threading.Thread
class Knight(threading.Thread):
    # Инициализация рыцаря с параметрами имени и силы
    def __init__(self, name: str, power: int):
        # Вызов конструктора родительского класса (threading.Thread)
        super().__init__()

        # Сохранение имени рыцаря
        self.name = name

        # Сохранение силы атаки рыцаря (сколько врагов он может победить за день)
        self.power = power

        # Изначальное количество врагов в битве
        self.enemies = 100

    # Метод, который будет выполняться в отдельном потоке
    def run(self):
        # Вывод сообщения о начале битвы
        print(f"{self.name}, на нас напали!")

        # Счетчик дней битвы
        day = 0

        # Цикл продолжается, пока есть враги
        while self.enemies > 0:
            # Увеличение счетчика дней
            day += 1

            # Имитация прохождения одного дня с помощью задержки
            time.sleep(1)

            # Уменьшение количества врагов на силу рыцаря
            self.enemies -= self.power

            # Защита от отрицательного количества врагов
            remaining = max(self.enemies, 0)

            # Вывод информации о ходе битвы
            print(f"{self.name} сражается {day} день(дня)..., осталось {remaining} воинов.")

        # Вывод сообщения о победе
        print(f"{self.name} одержал победу спустя {day} дней(дня)!")


# Создание экземпляров рыцарей с разной силой
first_knight = Knight('Sir Lancelot', 10)  # Первый рыцарь с силой 10
second_knight = Knight("Sir Galahad", 20)  # Второй рыцарь с силой 20

# Запуск потоков для каждого рыцаря
first_knight.start()
second_knight.start()

# Ожидание завершения обоих потоков
first_knight.join()
second_knight.join()

# Вывод сообщения о завершении всех битв
print("Все битвы закончились!")